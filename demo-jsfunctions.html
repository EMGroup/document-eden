<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="document-eden/document-eden.css" />    
    <script src="js-eden/js/lib/jquery-3.5.1.min.js"></script>
    <script src="js-eden/js/core/jseden.min.js"></script>    
    <script src="js-eden/plugins/jseden-plugins.min.js"></script>
    <script src="js-eden/js/ui/jseden-ui.min.js"></script>
    <script src="document-eden/document-eden.min.js"></script>
    <script>
      URLUtil.prefix = "js-eden/";
      window.allReadyResolve;
      window.allReady = new Promise((resolve)=>{ window.allReadyResolve = resolve});
      setTimeout(()=>{
        window.edenProjectLoaded.then(window.allReadyResolve);
      },1000);
      window.DE = window.DocumentEden;
    </script>
    <!-- User defined jsFunctions -->
    <script>
      let jsFunctions = {};
      jsFunctions.square = (n)=>{
        return n * n;
      };
      jsFunctions.cube = (n)=>{
        return n * n * n;
      }
      jsFunctions.multiply = ([a,b])=>{
        return a * b;
      }
      jsFunctions["waitasecond"] = (n)=>{
        let myPromise = new Promise((resolve,reject)=>{
          setTimeout(()=>{
            let result = n * n;
            resolve(result);
          },n*10);
        });
        return myPromise;
      }
      callJSFunction = function(context,scope){
        try{
          let result;
          let jsfunction = context.lookup("jsName").value(scope);
          console.log(jsfunction);
          try{
            result = jsFunctions[context.lookup("jsName").value(scope)](context.lookup("params").value(scope));
          }catch(ex){
            console.error(ex);
          }
          if(typeof result === 'object' && typeof result.then === 'function'){
            //Need to make this address unique rather than just functionName - but also need to prevent it from creating loads of them. 
            let addr = functionName + "_result";
            result.then((v)=>{
              context.lookup(addr).assign(v,context.scope,EdenSymbol.jsAgent);
            });
            return addr;
          }else{
            return result;
          }
        }catch(ex){
          console.error(ex);
        }

      }
    </script>
    <script type="text/jseden">
        jsCall is ${{callJSFunction(context,scope)}}$::jsName = jsName, params = params;
        n = 5;
        n2 is jsCall with jsName = "square", params = [n];
        n3 is jsCall with jsName = "cube", params = [n];
        nm is jsCall with jsName = "multiply", params = [n,m];
        second is jsCall with jsName = "waitasecond", params = [n];
        second_again is jsCall with jsName = "waitasecond", params = [n+1];
    </script>
    <style>
      .jseden-extract{
        font-family: 'Courier New', Courier, monospace;
        color:darkblue;
        font-size: small;
        font-weight: bold;

      }
      .js-extract{
        font-family: 'Courier New', Courier, monospace;
        color: darkgreen;
        font-size: small;
        font-weight: bold;
      }
    </style>
</head>
<body>
  <p>This page demonstrates how to call JavaScript functions from JSEden code.</p>
  <p>The functions used on this page illustrate how to pass parameters and retrieve return values from basic JavaScript functions - there is no need for these particular functions (as the maths functions already exist in JSEden &mdash; e.g. <span class="jseden-extract">b is pow(a,2)</span>).</p>
  <hr>
  <p>The source of this page shows how the functions are called.</p>
  <p>In the JSEden <span class="js-extract">script type="text/jseden"</span> tag:</p>
  <ul>
    <li>The <span class="jseden-extract">jsCall</span> definition allows for arbitrary functions to be called from the <span class="js-extract">jsFunctions</span> object</li>
    <li><span class="jseden-extract">jsCall</span> passes the <span class="jseden-extract">params</span> observable as a parameter to the user-defined JavaScript function</li>
  </ul>
  <p>In the JavaScript <span class="js-extract">script</span> tag:</p>
  <ul>
    <li>A <span class="js-extract">jsFunctions</span> object stores functions that can be called from JSEden</li>
    <li>Each function unpacks the <span class="jseden-extract">params</span> object into separate parameters to the JavaScript function</li>
  </ul>
  <p>Each JSEden definition passes an observable called <span class="jseden-extract">params</span> that define parameters that are required by that function. These ensure the params passed to the JavaScript function via the <span class="jseden-extract">jsCall</span> definition have the current scope, e.g.:</p>
  <ul>
    <li><span class="jseden-extract">n2 is jsCall with jsName = "square", params = [n];</span></li>
    <li><span class="jseden-extract">nm is jsCall with jsName = "multiply", params = [n,m];</span></li>
  </ul>
  <p>Whenever any of the observables within the <span class="jseden-extract">params</span> list are modified, the JavaScript function will be re-evaluated.</p>
  <hr>
  <p>n: £n=5£</p>
  <p>n<sup>2</sup>: £n2£</p>
  <p>n<sup>3</sup>: £n3£</p>
  <p>m: £m=6£</p>
  <p>m<sup>2</sup>: £n2 with n is m£</p>
  <p>m<sup>3</sup>: £n3 with n is m£</p>
  <p>n &times; m: £nm£</p>
  <p>£second£</p>
  <p>£`{second}`£</p>
  <p>£`{second_again}`£</p>
</body>
</html>